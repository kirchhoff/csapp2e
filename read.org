#+STYLE: <link rel="stylesheet" type="text/css" href="./style.css" />
#+TITLE: CSAPP 读书笔记
* 第二章 信息的处理和表示
** C语言中的位级表示
*** 交换两个值
   #+BEGIN_SRC c
void inplace_swap(int *x,int *y)
{
     *x = *x ^ *y;
     *y = *x ^ *y;
     *x = *x ^ *y;
}
   #+END_SRC
这种交换方式并没有性能上的优势，仅仅是个智力游戏
| /      | <> | <>   |
| 步骤   | *x | *y   |
|--------+----+------|
| 初始   | a  | b    |
|--------+----+------|
| 第一步 | a  | a\^b |
|--------+----+------|
| 第二步 | b  | a\^b |
|--------+----+------|
| 第三步 | b  | a    |
|--------+----+------|

_网络资料_ ：异或运算的作用
1. 0异或任何数=任何数
2. 1异或任何数=任何数取反
3. 任何数异或自己＝把自己置0

按位异或的几个常见用途:
+ 使某些特定的位翻转
  例如对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算。
　　　　　  10100001\^00000110 = 10100111
+ 在汇编语言中经常用于将变量置零：
  xor a，a
+ 快速判断两个值是否相等
  举例1: 判断两个整数a，b是否相等，则可通过下列语句实现：
        return ((a ^ b) == 0)

*** 习题2.12
| /                                                           | <          |
| x的最低有效字节，其他位置均置为0                            | x=0xFF&x   |
|-------------------------------------------------------------+------------|
| 除了x的最低有效字节外，其他的位都取补，最低有效字节保持不变 | x=x\^~0xFF |
|-------------------------------------------------------------+------------|
| x的最低有效字节设置成全1，其他字节都保持不变                | x=0xFFx    |
|-------------------------------------------------------------+------------|
*** 习题2.13
设bic(x,m)为在m为1的每个位置，将x对应的位设置为0,则bic(x,m) == x&~m

x\^y=(x&~y)|(~x&y)
** C语言中的移位运算
    - 逻辑右移 :: 在左端补k个0
    - 算术右移 :: 在左端补k个最高有效位的值
    - 移动k位，这里k很大 :: C语言标准很小心地规避了说明在这种情况下该如何做。实际上位移量就是通过计算k mod w得到的，例如w=32,即32位机，右移36位即4位，左移32位即0位，右移40位即8位
** 整数表示
补码的范围是不对称的：|TMin|=|TMax|+1,也就是说TMin没有与之对应的正数。之所有有这样的不对称性，是因为一半
的位模式(符号位设置为1的数)表示负数，而一半的数(符号位设置为0的数)表示非负数。因为0是非负数，也就意味着能表示的正数比
负数少一个。第二，最大的无符号数值刚好比补码的最大值的两倍大一点：UMax_{w}=2TMax_{w}+1。补码表示中所有表示负数的位模式在无
符号表示中都变成了正数。注意-1和UMax有同样的为表示——一个全1的串。数值0在两种表示中都是全0的串。
| 数       | 字长8 |
|----------+-------|
| /        | <>    |
|----------+-------|
| UMax_{w} |  0xFF |
|          |   255 |
|----------+-------|
| TMin_{w} |  0x80 |
|          |  -128 |
|----------+-------|
| TMax_{w} |  0x7F |
|          |   127 |
|----------+-------|
| -1       |  0xFF |
| 0        |  0x00 |
|----------+-------|
C库中的文件<limits.h>定义了一组常量，来限定编译器运行这台机器的不同整型数据类型的取值范围。比如，它定义了常量INT\_MAX、INT\_MIN和UINT\_MAX,它们描述了有符号和无符号整数的范围。
ISO C99标准在文件stdint.h中引入了另一类整数类型。这个文件定义了一组数据类型，它们的声明形如intN\_t和uintN\_t，指定的是N位有符号和无符号整数。N的具体值与实现相关，但是大多数编译器允许的值为8，16，32和64。
*** 有符号数和无符号数之间的转换
强制类型转换的结果保持位值不变，知识改变了解释这些位的方式。-12345的16位补码表示与53191的16位无符号表示是完全一样的。

在C语言中，当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制转换为无符号数，并假设这两个数都是非负的，来执行这个运算。

这种方法对于标准的算术运算来说并无多大差异，但是对于像<和>这样的关系运算符来说，会导致非直观的结果。

| 表达式                         | 类型   | 求值 |
|--------------------------------+--------+------|
| /                              | <      | <    |
|--------------------------------+--------+------|
| 0 == 0U                        | 无符号 |    1 |
|--------------------------------+--------+------|
| -1 < 0                         | 有符号 |    1 |
|--------------------------------+--------+------|
| -1 < 0U                        | 无符号 |   0* |
|--------------------------------+--------+------|
| 2147483647 > -2147483647-1     | 有符号 |    1 |
|--------------------------------+--------+------|
| 2147483647U > -2147483647-1    | 无符号 |   0* |
|--------------------------------+--------+------|
| 2147483647 > (int) 2147483648U | 有符号 |   1* |
|--------------------------------+--------+------|
| -1 > -2                        | 有符号 |    1 |
|--------------------------------+--------+------|
| (unsigned) -1 > 2              | 无符号 |    1 |
|--------------------------------+--------+------|
注：非直观的情况标注了"*"

*** 习题2.21
| 表达式                       | 类型 | 求值 |
|------------------------------+------+------|
| /                            | <    | <    |
|------------------------------+------+------|
| -2147483647-1 == 2147483648U | 无   | 1*   |
|------------------------------+------+------|
| -2147483647-1 < 2147483647   | 有   | 1    |
|------------------------------+------+------|
| -2147483647-1U < 2147483647  | 无   | 0*   |
|------------------------------+------+------|
| -2147483647-1 < -2147483647  | 有   | 1    |
|------------------------------+------+------|
| -2147483647-1U < -2147483647 | 无   | 0*   |
|------------------------------+------+------|

*** 扩展一个数字的位表示
    将一个无符号数转换为一个更大的数据类型，我们只需要在表示的开头添加0，这种运算称为 =零扩展= 。将一个补码数字转换为一个更大的数据类型可以执行 =符号扩展= ,规则是在表示中添加最高的有效位的值的副本。
设short x=-12345,把short转换为unsigned时，我们先要改变大小，之后再完成从有符号到无符号的转换，也就是说(unsigned)x等价于(unsigned)(int)sx,求值得到4294954951,而不等价于(unsigned)(unsigned short)x,后者求值得到53191。事实上，这个规则是C语言标准要求的。

*** 习题2.27
这个函数是对确定无符号加法是否溢出的规则的直接实现。如果参数x和y相加不会产生溢出，这个函数就返回1。
#+BEGIN_SRC C
int uadd_ok(unsigned x,unsigned y)
{
    unsigned sum = x+y;
    return sum >= x;
}
#+END_SRC

*** 习题2.30
这个函数是对确定补码加法是否溢出的规则的直接实现
#+BEGIN_SRC c
int tadd_ok(int x,int y)
{
    int sum = x+y;
    int neg_over = x < 0 && y <0 && sum >= 0;
    int pos_over = x >= 0 && y>= 0 && sum < 0;
    return !neg_over && !pos_over;
}
#+END_SRC

*** 习题2.32
补码减法溢出
#+BEGIN_SRC c
int tsub_ok(int x,int y)
{
    int sub = x - y;
    return (x >= y)?(sub >= 0):(sub < 0);
}
#+END_SRC
*** 补码非的位级表示
对每一位求补，再对结果+1，在C语言中，我们可以确定对于任意整数值x，计算表达式-x和~x+1得到的结果完全一样。

*** 习题2.34
| 模式     | x       | y       | x*y        | 截断的x*y |
|----------+---------+---------+------------+-----------|
| /        | <       | <       | <          | <         |
|----------+---------+---------+------------+-----------|
| 无符号数 | 4  100  | 5  101  | 20  010100 | 4  100    |
| 补码     | -4  100 | -3  101 | 12  001100 | -4  100   |
|----------+---------+---------+------------+-----------|
| 无符号数 | 2  010  | 7  111  | 14  001110 | 6  110    |
| 补码     | 2  010  | -1  111 | 12  111110 | -2  110   |
|----------+---------+---------+------------+-----------|
| 无符号数 | 2  010  | 7  111  | 14  001110 | 6  110    |
| 补码     | 2  010  | -1  111 | 12  111110 | -2  110   |
|----------+---------+---------+------------+-----------|
我们可以看出，w位数字上的无符号运算和补码运算是同构的------加减乘在位级上有相同的结果。
